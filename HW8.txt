Michael Quinn
DON'T FORGET TO TAR THIS THIS TIME
1. Pg. 237 CYU 8, 9 and 11
#8: Why is the distinction between mutable and immutable values important in the implementation of a language with a reference model of variables?
	A mutable value can change, or mutate; an immutable value cannot. This is important within languages because most languages make use of mutable values, which are generally supposed to change; additionally, these languages allow for assigning an immutable value to mutable variables, but will not allow the reverse. Therefore, tracking which variables are mutable and which are immutable is important. Some variables cannot be changed, or at least cannot be changed in certain circumstances, so tracking which are which is very important to allow programs written in the language to work properly.

#9: Define orthogonality in the context of programming language design.
	Orthogonality is the measure to which various language features may be used in logical and sensible combinations with one another. For instance, I would describe Prolog as more orthogonal than Java, specifically regarding variable typing, anyways.

#10: What is the difference between a statement and an expression? What does it mean for a language to be expression-oriented?
	Expressions are blocks of code that evaluate, generally through operators, to produce a value, and generally produce no "side-effects"; statements are blocks of code that are executed in order to produce such "side-effects", and generally do not return useful values. An effect is a "side-effect" if it affects computation in any way other than returning a value.


2. Evaluate following program fragment in C:
	int a = 0;      
	int b = (a++ || ++a) >= (a++ && ++a);
	printf( "%d %d", a, b );
In the table below show each evaluation step  and include the value of a and b.  Finally, display the output.
Remember that in Java, C, and C++, && and || are both short circuit operators which are always evaluated left to right.
Assume all side effects occur immediately. 
The '++' and '--' operators have higher precedence than '+' . The '+', additive operator, has higher precedence than '&&' or '||'. The '=' operator has lowest precedence.

a. Assume that, wherever there is an option, operands are evaluated left to right:

int b = (a++ || ++a) >= (a++ && ++a);	|		a=0			b=?
int b = (0 || ++a) >= (a++ && ++a);		|		a=1			b=?
int b = (0 || 2) >= (a++ && ++a);		|		a=2			b=?
int b = (1) >= (a++ && ++a);			|		a=2			b=?
int b = 1 >= (a++ && ++a);				|		a=2			b=?
int b = 1 >= (2 && ++a);				|		a=3			b=?
int b = 1 >= (2 && 4);					|		a=4			b=?
int b = 1 >= (1);						|		a=4			b=?
int b = 1 >= 1;							|		a=4			b=?
int b = 1;								|		a=4			b=?
1;										|		a=4			b=1

b. Assume that, wherever there is an option, operands are evaluated right to left:

int b = (a++ || ++a) >= (a++ && ++a);	|		a=0			b=?
int b = (a++ || ++a) >= (0 && ++a);		|		a=1			b=?
int b = (a++ || ++a) >= (0);			|		a=1			b=?
int b = (a++ || ++a) >= 0;				|		a=1			b=?
int b = (1 || ++a) >= 0;				|		a=2			b=?
int b = (1) >= 0;						|		a=2			b=?
int b = 1 >= 0;							|		a=2			b=?
int b = 1;								|		a=2			b=?
1;										|		a=2			b=1


3. C++ and Java loops are often written with empty bodies by placing all side effects into the tests, such as in the following two examples:
	i = 0;
	while (a[i++] != 0);

	for (i = 0; a[i] != 0; i++);
Are these loops equivalent? Explain.
	No; functionally, each loop continuously runs the expression "a[i]", and stops once that expression returns 0; however, the first loop has the "i" variable in a larger scope than the second loop, in which "i" only holds meaning during the loop itself; the first loop allows later code to reference "i" such that "a[i]==0", while the second loop doesn't.
	That said, both loops call the same code; the first just gives more options to code down the line by preserving more information. That is not, however, considered equivalent.


4. Page 291 exercise 6.33: Give an example in C in which an in-line subroutine may be significantly faster than a functionally equivalent macro. Give another example in which the macro is likely to be faster. (Hint: Think about applicative vs normalorder
evaluation of arguments.

	Example 1: An in-line subroutine would be significantly faster than an equivalent macro if the information is used repeatedly within a loop, especially if the information contains complex function calls that don't have side effects:
	
	int output = (x+3)%(y/3);
	int arr[10000];
	for(long i=0; i<arr.length; i++){
		arr[i]=i%output;
	}
	
	vs
	
	#DEFINE OUTPUT(A,B) ((A+3)%(B/3))
	...
	int arr[10000];
	for(long i=0; i<arr.length; i++){
		arr[i]=i%OUTPUT(x,y);
	}
	
	Example 2: A macro expression would be significantly faster than an in-line subroutine if the code itself is expensive to run, such as printing something out to the console, and has a high chance of not needing to be called; or if a conditional statement's chance of running is determined at compile-time, and the conditional statement is called often, in which case it could be replaced with a conditional macro
	
	#DEFINE DEBUG_MODE false
	...
	for(int i=0; i<10000; i++){
		int x = foo(i);
		#IF DEBUG_MODE
		printf("x=%d", x);
		#ENDIF
		...
	}
	
	bool debug_mode = false;
	...
	for(int i=0; i<10000; i++){
		int x = foo(i);
		if(debug_mode)
			printf("x=%d", x);
		...
	}


5. Page 311/12 CYU 2, 9, 10:
#2: What does it mean for a language to be strongly typed? Statically typed? What prevents, say, C from being strongly typed?
	A language is strongly typed if it can meaningfully prohibit operations from being performed on objects of types that the operation is not programmed for; for instance, from performing an assignment operation between a character and a struct.
	A language is statically typed if it is strongly typed and these checks to prevent operations between incompatible types can be performed at compile-time.
	C is prevented from being strongly typed thanks to pointers, which can be cast as any other type of pointer (either directly or through void pointers), effectively allowing for casting any object as any other type of object without objection from the compiler. Therefore, C's typing is an imperfect tool, and can be easily violated without complaint from the machine (though it will still cause issues); effectively, C is too trusting of the programmer.

#9: What is polymorphism? What distinguishes its parametric and subtype varieties? What are generics?
	Polymorphism is the degree to which code can work (is designed to work) using multiple different types of objects.
	Parametric polymorphism is polymorphism regarding function parameters; this includes both functions that is written to take multiple types of objects (such as int Math.pow(int, int) and double Math.pow(double, double)), and code that can take multiple types due to automatic casting (such as double fmod(double, double), which could take an integer for either parameter and cast it to a double).
	Subtype Polymorphism is polymorphism regarding subtypes in object-oriented languages, such as subclasses; for instance, if someone wrote a Parent class, they could also write a Grandparent subclass of the Parent class, and any expression that allows a Parent would also allow a Grandparent in its place.
	Generics are a case of "explicit parametric polymorphism," in which a function can take a wide range of parameter types provided they follow a specific "template" (for instance, any sort function just requires that the elements being sorted can be compared to one another; any arithmetic operator just requires that the elements are a type of number; etc.). Vectors are a well-suited example; they can hold elements of any type of object, provided that all of their elements are of that type of object.

#10: What is the difference between discrete and scalar types?
	A discrete object type is any object type that follows these two principles; they are either countably finite or countably infinite (either theoretically or in practice), and there is a defined "previous" and "next" for any element in the set aside from the "first" and "last" of the set, if applicable. For instance, integers, characters, and booleans are all discrete types; but irrational numbers would not be.
	Scalar types are a larger grouping of types that includes discrete types, as well as rational and real numbers, and complex types; basically anything that doesn't contain a list or matrix of some sort; singular groupings of data rather than collections of data. Scalar data takes up a defined amount of memory, with a clear maximum space for each type.
	All discrete data types are also scalar data types, but discrete data can be incremented and decremented using a preexisting "unit" that is defined by the type itself.


6. Page 342 cyu 27: What is duck typing? What is its connection to polymorphism? In what languages does it appear?
	Quack! Am I a duck? Duck typing would say yes, because I just quacked. But if it asked me to fly, I would no longer be a duck, and it would produce an error. Duck typing assumes that any given object is of the type it is expecting until it asks it to do something that object cannot do.
	Duck typing is very useful for polymorphism, as it effectively ignores type checking until it is absolutely needed, such as when an operation is performed on an object that has requirements for it; like a factory where one step is to attach two parts together, even if the parts aren't what they are supposed to be the factory will still work with them until there is a step where they can't be attached the way they are supposed to. Duck typing increases polymorphism by assuming the correct type until an operation can't be performed on an object.
	Duck typing is the bread and butter of Prolog; but it also appears in Objective C, Swift, Python, and Ruby.


