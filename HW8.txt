Michael Quinn
DON'T FORGET TO TAR THIS THIS TIME
1. Pg. 237 CYU 8, 9 and 11
#8: Why is the distinction between mutable and immutable values important in the implementation of a language with a reference model of variables?
	A mutable value can change, or mutate; an immutable value cannot. This is important within languages because most languages make use of mutable values, which are generally supposed to change; additionally, these languages allow for assigning an immutable value to mutable variables, but will not allow the reverse. Therefore, tracking which variables are mutable and which are immutable is important. Some variables cannot be changed, or at least cannot be changed in certain circumstances, so tracking which are which is very important to allow programs written in the language to work properly.

#9: Define orthogonality in the context of programming language design.
	Orthogonality is the measure to which various language features may be used in logical and sensible combinations with one another. For instance, I would describe Prolog as more orthogonal than Java, specifically regarding variable typing, anyways.

#10: What is the difference between a statement and an expression? What does it mean for a language to be expression-oriented?
	Expressions are blocks of code that evaluate, generally through operators, to produce a value, and generally produce no "side-effects"; statements are blocks of code that are executed in order to produce such "side-effects", and generally do not return useful values. An effect is a "side-effect" if it affects computation in any way other than returning a value.


2. Evaluate following program fragment in C:
	int a = 0;      
	int b = (a++ || ++a) >= (a++ && ++a);
	printf( "%d %d", a, b );
In the table below show each evaluation step  and include the value of a and b.  Finally, display the output.
Remember that in Java, C, and C++, && and || are both short circuit operators which are always evaluated left to right.
Assume all side effects occur immediately. 
The '++' and '--' operators have higher precedence than '+' . The '+', additive operator, has higher precedence than '&&' or '||'. The '=' operator has lowest precedence.

a. Assume that, wherever there is an option, operands are evaluated left to right:

int b = (a++ || ++a) >= (a++ && ++a);	|		a=0			b=?
int b = (0 || ++a) >= (a++ && ++a);		|		a=1			b=?
int b = (0 || 2) >= (a++ && ++a);		|		a=2			b=?
int b = (1) >= (a++ && ++a);			|		a=2			b=?
int b = 1 >= (a++ && ++a);				|		a=2			b=?
int b = 1 >= (2 && ++a);				|		a=3			b=?
int b = 1 >= (2 && 4);					|		a=4			b=?
int b = 1 >= (1);						|		a=4			b=?
int b = 1 >= 1;							|		a=4			b=?
int b = 1;								|		a=4			b=?
1;										|		a=4			b=1

b. Assume that, wherever there is an option, operands are evaluated right to left:

int b = (a++ || ++a) >= (a++ && ++a);	|		a=0			b=?
int b = (a++ || ++a) >= (0 && ++a);		|		a=1			b=?
int b = (a++ || ++a) >= (0);			|		a=1			b=?
int b = (a++ || ++a) >= 0;				|		a=1			b=?
int b = (1 || ++a) >= 0;				|		a=2			b=?
int b = (1) >= 0;						|		a=2			b=?
int b = 1 >= 0;							|		a=2			b=?
int b = 1;								|		a=2			b=?
1;										|		a=2			b=1


3. C++ and Java loops are often written with empty bodies by placing all side effects into the tests, such as in the following two examples:
	i = 0;
	while (a[i++] != 0);

	for (i = 0; a[i] != 0; i++);
Are these loops equivalent? Explain.
	No; functionally, each loop continuously runs the expression "a[i]", and stops once that expression returns 0; however, the first loop has the "i" variable in a larger scope than the second loop, in which "i" only holds meaning during the loop itself; the first loop allows later code to reference "i" such that "a[i]==0", while the second loop doesn't.
	That said, both loops call the same code; the first just gives more options to code down the line by preserving more information. That is not, however, considered equivalent.


4. Page 291 exercise 6.33: Give an example in C in which an in-line subroutine may be significantly faster than a functionally equivalent macro. Give another example in which the macro is likely to be faster. (Hint: Think about applicative vs normalorder
evaluation of arguments.

	Example 1: An in-line subroutine would be significantly faster than an equivalent macro if the information is used repeatedly within a loop, especially if the information contains complex function calls that don't have side effects:
	
	int output = (x+3)%(y/3);
	int arr[10000];
	for(long i=0; i<arr.length; i++){
		arr[i]=i%output;
	}
	
	vs
	
	#DEFINE OUTPUT(A,B) ((A+3)%(B/3))
	...
	int arr[10000];
	for(long i=0; i<arr.length; i++){
		arr[i]=i%OUTPUT(x,y);
	}
	
	Example 2: A macro expression would be significantly faster than an in-line subroutine if the code itself is expensive to run, such as printing something out to the console, and has a high chance of not needing to be called; or if a conditional statement's chance of running is determined at compile-time, and the conditional statement is called often, in which case it could be replaced with a conditional macro
	
	#DEFINE DEBUG_MODE false
	...
	for(int i=0; i<10000; i++){
		int x = foo(i);
		#IF DEBUG_MODE
		printf("x=%d", x);
		#ENDIF
		...
	}
	
	bool debug_mode = false;
	...
	for(int i=0; i<10000; i++){
		int x = foo(i);
		if(debug_mode)
			printf("x=%d", x);
		...
	}


